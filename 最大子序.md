## 最大子序的范围和最大子序和的求解。
- 采用最简单的cpp语言规范实现，使用分冶的思想求解，其时间复杂度为O(nlgn)，
```c++
struct data {
    int low;
    int high;
    int sum;
};

data findMaxCrossingSubArray(int *array, int low, int high) {
    data maxCrossSubArray{};
    int mid = (low + high) / 2;
    int sum = 0;

    int leftSum = array[mid] - 1;
    int maxLeft = 0;
    for (int i = mid; i >= low; --i) {
        sum += array[i];
        if (sum > leftSum) {
            leftSum = sum;
            maxLeft = i;
        }
    }
    sum = 0;

    int rightSum = array[mid + 1] - 1;
    int maxRight = 0;
    for (int i = mid + 1; i <= high; ++i) {
        sum += array[i];
        if (sum > rightSum) {
            rightSum = sum;
            maxRight = i;
        }
    }

    maxCrossSubArray.low = maxLeft;
    maxCrossSubArray.high = maxRight;
    maxCrossSubArray.sum = leftSum + rightSum;

    return maxCrossSubArray;
}
// 利用分冶思想
data findMaxSubArray(int *array, int low, int high) {
    // 触底条件子数组中的元素的个数为一个
    if (high == low) {
        data maxSubArray{};
        maxSubArray.low = low;
        maxSubArray.high = high;
        maxSubArray.sum = array[low];
        return maxSubArray;
    } else {
        int mid = (low + high) / 2;
        data leftData{}, rightData{}, crossingData{};
        leftData = findMaxSubArray(array, low, mid);
        rightData = findMaxSubArray(array, mid + 1, high);
        crossingData = findMaxCrossingSubArray(array, low, high);
        // 将低层次的最大子数组即一个data类型的数据，送回上层函数中。
        if (leftData.sum >= rightData.sum && leftData.sum >= crossingData.sum) {
            return leftData;
        } else if (rightData.sum >= leftData.sum && rightData.sum >= crossingData.sum) {
            return rightData;
        } else {
            return crossingData;
        }
    }
}
```
